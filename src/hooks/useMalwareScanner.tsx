import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import DeviceDiagnostics from '@/plugins/DeviceStoragePlugin';
import { Capacitor } from '@capacitor/core';

export interface MalwareDefinitions {
  version: string;
  lastUpdate: string;
  knownMalware: string[];
  knownAdware: string[];
  suspiciousPatterns: string[];
  suspiciousAppNames: string[];
  dangerousPermissionCombos: string[][];
  threatCategories: Record<string, {
    severity: string;
    description: string;
    action: string;
  }>;
  trustedSources: string[];
  systemAppWhitelist: string[];
}

export interface ScanResult {
  packageName: string;
  appName: string;
  threatLevel: 'malware' | 'trojan' | 'adware' | 'pua' | 'suspicious' | 'safe';
  severity: 'critical' | 'high' | 'medium' | 'low' | 'none';
  reasons: string[];
  permissions: string[];
  isSystemApp: boolean;
  installSource?: string;
  recommendation: string;
}

export interface ScanSummary {
  totalApps: number;
  scannedApps: number;
  malwareCount: number;
  adwareCount: number;
  puaCount: number;
  suspiciousCount: number;
  safeCount: number;
  scanDuration: number;
  scanDate: Date;
}

interface ScanState {
  isScanning: boolean;
  progress: number;
  currentApp: string;
  results: ScanResult[];
  summary: ScanSummary | null;
  error: string | null;
}

export const useMalwareScanner = () => {
  const [state, setState] = useState<ScanState>({
    isScanning: false,
    progress: 0,
    currentApp: '',
    results: [],
    summary: null,
    error: null
  });
  
  const [definitions, setDefinitions] = useState<MalwareDefinitions | null>(null);
  const [lastDefinitionsUpdate, setLastDefinitionsUpdate] = useState<Date | null>(null);
  const [isUpdatingDefinitions, setIsUpdatingDefinitions] = useState(false);

  const fetchDefinitions = useCallback(async (forceRefresh: boolean = false): Promise<MalwareDefinitions | null> => {
    try {
      // Check cache (1 hour) - skip if force refresh
      if (!forceRefresh && definitions && lastDefinitionsUpdate) {
        const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
        if (lastDefinitionsUpdate > hourAgo) {
          return definitions;
        }
      }

      setIsUpdatingDefinitions(true);

      const { data, error } = await supabase.functions.invoke('malware-definitions', {
        body: { action: 'getAll' }
      });

      if (error) throw error;

      setDefinitions(data);
      setLastDefinitionsUpdate(new Date());
      console.log(`[MalwareScanner] Definitions updated: v${data.version}`);
      return data;
    } catch (error) {
      console.error('Error fetching malware definitions:', error);
      return null;
    } finally {
      setIsUpdatingDefinitions(false);
    }
  }, [definitions, lastDefinitionsUpdate]);

  // Force update definitions (bypass cache)
  const forceUpdateDefinitions = useCallback(async (): Promise<boolean> => {
    const result = await fetchDefinitions(true);
    return result !== null;
  }, [fetchDefinitions]);

  const analyzeApp = useCallback((
    app: { packageName: string; appName: string; permissions?: string[]; isSystemApp?: boolean },
    defs: MalwareDefinitions
  ): ScanResult => {
    const reasons: string[] = [];
    let threatLevel: ScanResult['threatLevel'] = 'safe';
    let severity: ScanResult['severity'] = 'none';

    const packageLower = app.packageName.toLowerCase();
    const appNameLower = app.appName.toLowerCase();
    const permissions = app.permissions || [];

    // Check if whitelisted system app
    const isWhitelisted = defs.systemAppWhitelist.some(prefix => 
      packageLower.startsWith(prefix.toLowerCase())
    );

    if (!isWhitelisted) {
      // Check known malware
      if (defs.knownMalware.some(m => packageLower === m.toLowerCase())) {
        threatLevel = 'malware';
        severity = 'critical';
        reasons.push('Package identificato come malware noto');
      }

      // Check known adware
      if (threatLevel === 'safe' && defs.knownAdware.some(a => packageLower === a.toLowerCase())) {
        threatLevel = 'adware';
        severity = 'high';
        reasons.push('Package identificato come adware noto');
      }

      // Check suspicious patterns in package name
      if (threatLevel === 'safe') {
        for (const pattern of defs.suspiciousPatterns) {
          try {
            const regex = new RegExp(pattern, 'i');
            if (regex.test(packageLower)) {
              threatLevel = 'pua';
              severity = 'medium';
              reasons.push(`Nome package sospetto: ${pattern}`);
              break;
            }
          } catch (e) {
            // Invalid regex, skip
          }
        }
      }

      // Check suspicious app names
      if (threatLevel === 'safe') {
        for (const name of defs.suspiciousAppNames) {
          if (appNameLower.includes(name.toLowerCase())) {
            threatLevel = 'suspicious';
            severity = 'low';
            reasons.push(`Nome app sospetto: contiene "${name}"`);
            break;
          }
        }
      }

      // Check dangerous permission combinations
      for (const combo of defs.dangerousPermissionCombos) {
        const hasAllPermissions = combo.every(perm => 
          permissions.some(p => p.includes(perm.split('.').pop() || ''))
        );
        if (hasAllPermissions) {
          if (threatLevel === 'safe') {
            threatLevel = 'suspicious';
            severity = 'low';
          }
          reasons.push(`Combinazione permessi pericolosa rilevata`);
          break;
        }
      }
    }

    // Get recommendation from threat category
    const category = defs.threatCategories[threatLevel] || defs.threatCategories.safe;

    return {
      packageName: app.packageName,
      appName: app.appName,
      threatLevel,
      severity,
      reasons,
      permissions,
      isSystemApp: app.isSystemApp || false,
      recommendation: category.action
    };
  }, []);

  const startScan = useCallback(async (quickScan: boolean = false) => {
    if (!Capacitor.isNativePlatform()) {
      setState(prev => ({ ...prev, error: 'Scanner disponibile solo su dispositivi Android' }));
      return;
    }

    setState({
      isScanning: true,
      progress: 0,
      currentApp: 'Caricamento definizioni...',
      results: [],
      summary: null,
      error: null
    });

    const startTime = Date.now();

    try {
      // Fetch definitions
      const defs = await fetchDefinitions();
      if (!defs) {
        throw new Error('Impossibile caricare le definizioni malware');
      }

      setState(prev => ({ ...prev, progress: 10, currentApp: 'Recupero lista app...' }));

      // Get installed apps with permissions
      const { apps } = await DeviceDiagnostics.getDangerousPermissions();
      
      if (!apps || apps.length === 0) {
        throw new Error('Nessuna app trovata');
      }

      // Filter for quick scan (only non-system apps)
      const appsToScan = quickScan 
        ? apps.filter(app => !app.isSystemApp)
        : apps;

      const results: ScanResult[] = [];
      const totalApps = appsToScan.length;

      for (let i = 0; i < appsToScan.length; i++) {
        const app = appsToScan[i];
        const progress = 10 + Math.floor((i / totalApps) * 85);
        
        setState(prev => ({
          ...prev,
          progress,
          currentApp: app.appName || app.packageName
        }));

        const result = analyzeApp({
          packageName: app.packageName,
          appName: app.appName,
          permissions: app.permissions,
          isSystemApp: app.isSystemApp
        }, defs);

        results.push(result);

        // Small delay for UI update
        if (i % 10 === 0) {
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      }

      // Calculate summary
      const summary: ScanSummary = {
        totalApps: apps.length,
        scannedApps: appsToScan.length,
        malwareCount: results.filter(r => r.threatLevel === 'malware' || r.threatLevel === 'trojan').length,
        adwareCount: results.filter(r => r.threatLevel === 'adware').length,
        puaCount: results.filter(r => r.threatLevel === 'pua').length,
        suspiciousCount: results.filter(r => r.threatLevel === 'suspicious').length,
        safeCount: results.filter(r => r.threatLevel === 'safe').length,
        scanDuration: Date.now() - startTime,
        scanDate: new Date()
      };

      // Sort by severity
      const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, none: 4 };
      results.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

      setState({
        isScanning: false,
        progress: 100,
        currentApp: '',
        results,
        summary,
        error: null
      });

    } catch (error) {
      console.error('Scan error:', error);
      setState(prev => ({
        ...prev,
        isScanning: false,
        error: error instanceof Error ? error.message : 'Errore durante la scansione'
      }));
    }
  }, [fetchDefinitions, analyzeApp]);

  const clearResults = useCallback(() => {
    setState({
      isScanning: false,
      progress: 0,
      currentApp: '',
      results: [],
      summary: null,
      error: null
    });
  }, []);

  return {
    ...state,
    definitions,
    lastDefinitionsUpdate,
    isUpdatingDefinitions,
    startScan,
    clearResults,
    refreshDefinitions: fetchDefinitions,
    forceUpdateDefinitions
  };
};
