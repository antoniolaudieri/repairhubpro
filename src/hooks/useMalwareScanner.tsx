import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import DeviceDiagnostics from '@/plugins/DeviceStoragePlugin';
import { Capacitor } from '@capacitor/core';

// ==========================================
// INTERFACES
// ==========================================

export interface MalwareDefinitions {
  version: string;
  releaseDate: string;
  lastUpdate: string;
  
  // Threat lists
  knownMalware: string[];
  knownAdware: string[];
  knownSpyware: string[];
  knownRiskware: string[];
  
  // Patterns
  suspiciousPatterns: string[];
  suspiciousAppNames: string[];
  suspiciousPatternsDetailed: Array<{ pattern: string; reason: string; severity: string }>;
  suspiciousAppNamesDetailed: Array<{ name: string; reason: string; severity: string }>;
  dangerousPermissionCombos: Array<{
    permissions: string[];
    reason: string;
    severity: string;
    threat_type: string;
  }>;
  
  // Categories
  threatCategories: Record<string, {
    severity: string;
    description: string;
    action: string;
  }>;
  trustedSources: string[];
  systemAppWhitelist: string[];
  
  // Stats
  totalThreats: number;
  malwareCount: number;
  adwareCount: number;
  spywareCount: number;
  
  // Metadata
  changelog?: string;
  source?: string;
}

export interface ScanResult {
  packageName: string;
  appName: string;
  iconBase64?: string;
  threatLevel: 'malware' | 'trojan' | 'spyware' | 'adware' | 'riskware' | 'pua' | 'suspicious' | 'safe';
  severity: 'critical' | 'high' | 'medium' | 'low' | 'none';
  reasons: Array<{ text: string; severity: string }>;
  permissions: string[];
  dangerousPermissions: string[];
  isSystemApp: boolean;
  installSource?: string;
  recommendation: string;
  riskScore: number; // 0-100
}

export interface ScanSummary {
  totalApps: number;
  scannedApps: number;
  malwareCount: number;
  spywareCount: number;
  adwareCount: number;
  riskwareCount: number;
  puaCount: number;
  suspiciousCount: number;
  safeCount: number;
  scanDuration: number;
  scanDate: Date;
  overallRiskScore: number;
  riskLevel: 'safe' | 'low' | 'medium' | 'high' | 'critical';
  definitionsVersion: string;
}

export interface SystemSecurityStatus {
  isRooted: boolean;
  isBootloaderUnlocked: boolean;
  isDeveloperOptionsEnabled: boolean;
  isUsbDebuggingEnabled: boolean;
  isPlayProtectEnabled?: boolean;
  securityPatchLevel?: string;
  encryptionStatus?: string;
  selinuxStatus?: string;
}

interface ScanState {
  isScanning: boolean;
  progress: number;
  currentApp: string;
  currentAppIcon?: string;
  phase: 'idle' | 'loading_definitions' | 'fetching_apps' | 'analyzing' | 'finalizing' | 'complete';
  results: ScanResult[];
  summary: ScanSummary | null;
  systemSecurity: SystemSecurityStatus | null;
  error: string | null;
  recentApps: Array<{ name: string; icon?: string; status: 'safe' | 'threat' | 'pending' }>;
}

// ==========================================
// CONSTANTS
// ==========================================

const DANGEROUS_PERMISSIONS = [
  'android.permission.SEND_SMS',
  'android.permission.READ_SMS',
  'android.permission.RECEIVE_SMS',
  'android.permission.READ_CONTACTS',
  'android.permission.WRITE_CONTACTS',
  'android.permission.READ_CALL_LOG',
  'android.permission.WRITE_CALL_LOG',
  'android.permission.RECORD_AUDIO',
  'android.permission.CAMERA',
  'android.permission.ACCESS_FINE_LOCATION',
  'android.permission.ACCESS_BACKGROUND_LOCATION',
  'android.permission.READ_EXTERNAL_STORAGE',
  'android.permission.WRITE_EXTERNAL_STORAGE',
  'android.permission.SYSTEM_ALERT_WINDOW',
  'android.permission.BIND_ACCESSIBILITY_SERVICE',
  'android.permission.REQUEST_INSTALL_PACKAGES',
  'android.permission.READ_PHONE_STATE',
  'android.permission.PROCESS_OUTGOING_CALLS'
];

// ==========================================
// HOOK
// ==========================================

export const useMalwareScanner = () => {
  const [state, setState] = useState<ScanState>({
    isScanning: false,
    progress: 0,
    currentApp: '',
    phase: 'idle',
    results: [],
    summary: null,
    systemSecurity: null,
    error: null,
    recentApps: []
  });
  
  const [definitions, setDefinitions] = useState<MalwareDefinitions | null>(null);
  const [lastDefinitionsUpdate, setLastDefinitionsUpdate] = useState<Date | null>(null);
  const [isUpdatingDefinitions, setIsUpdatingDefinitions] = useState(false);

  // ==========================================
  // FETCH DEFINITIONS FROM DB
  // ==========================================

  const fetchDefinitions = useCallback(async (forceRefresh: boolean = false): Promise<MalwareDefinitions | null> => {
    try {
      // Check cache (30 min) - skip if force refresh
      if (!forceRefresh && definitions && lastDefinitionsUpdate) {
        const halfHourAgo = new Date(Date.now() - 30 * 60 * 1000);
        if (lastDefinitionsUpdate > halfHourAgo) {
          return definitions;
        }
      }

      setIsUpdatingDefinitions(true);

      const { data, error } = await supabase.functions.invoke('malware-definitions', {
        body: { action: 'getAll' }
      });

      if (error) throw error;

      const defs = data as MalwareDefinitions;
      setDefinitions(defs);
      setLastDefinitionsUpdate(new Date());
      console.log(`[MalwareScanner] Definitions loaded: v${defs.version}, ${defs.totalThreats} threats`);
      return defs;
    } catch (error) {
      console.error('[MalwareScanner] Error fetching definitions:', error);
      return null;
    } finally {
      setIsUpdatingDefinitions(false);
    }
  }, [definitions, lastDefinitionsUpdate]);

  const forceUpdateDefinitions = useCallback(async (): Promise<boolean> => {
    const result = await fetchDefinitions(true);
    return result !== null;
  }, [fetchDefinitions]);

  // ==========================================
  // ANALYZE SINGLE APP
  // ==========================================

  const analyzeApp = useCallback((
    app: { 
      packageName: string; 
      appName: string; 
      permissions?: string[]; 
      isSystemApp?: boolean;
      iconBase64?: string;
    },
    defs: MalwareDefinitions
  ): ScanResult => {
    const reasons: Array<{ text: string; severity: string }> = [];
    let threatLevel: ScanResult['threatLevel'] = 'safe';
    let severity: ScanResult['severity'] = 'none';
    let riskScore = 0;

    const packageLower = app.packageName.toLowerCase();
    const appNameLower = app.appName.toLowerCase();
    const permissions = app.permissions || [];

    // Identify dangerous permissions
    const dangerousPermissions = permissions.filter(p => 
      DANGEROUS_PERMISSIONS.some(dp => p.includes(dp.split('.').pop() || ''))
    );

    // Check if whitelisted system app
    const isWhitelisted = defs.systemAppWhitelist.some(prefix => 
      packageLower.startsWith(prefix.toLowerCase())
    );

    if (!isWhitelisted) {
      // === CHECK KNOWN MALWARE ===
      if (defs.knownMalware.some(m => packageLower === m.toLowerCase())) {
        threatLevel = 'malware';
        severity = 'critical';
        riskScore = 100;
        reasons.push({ text: 'Package identificato come MALWARE noto', severity: 'critical' });
      }

      // === CHECK KNOWN SPYWARE ===
      if (threatLevel === 'safe' && defs.knownSpyware?.some(s => packageLower === s.toLowerCase())) {
        threatLevel = 'spyware';
        severity = 'critical';
        riskScore = 95;
        reasons.push({ text: 'Package identificato come SPYWARE noto', severity: 'critical' });
      }

      // === CHECK KNOWN ADWARE ===
      if (threatLevel === 'safe' && defs.knownAdware.some(a => packageLower === a.toLowerCase())) {
        threatLevel = 'adware';
        severity = 'high';
        riskScore = 75;
        reasons.push({ text: 'Package identificato come ADWARE noto', severity: 'high' });
      }

      // === CHECK KNOWN RISKWARE ===
      if (threatLevel === 'safe' && defs.knownRiskware?.some(r => packageLower === r.toLowerCase())) {
        threatLevel = 'riskware';
        severity = 'medium';
        riskScore = 60;
        reasons.push({ text: 'Package identificato come RISKWARE (strumento potenzialmente pericoloso)', severity: 'medium' });
      }

      // === CHECK SUSPICIOUS PATTERNS ===
      if (threatLevel === 'safe' && defs.suspiciousPatternsDetailed?.length > 0) {
        for (const patternObj of defs.suspiciousPatternsDetailed) {
          try {
            const regex = new RegExp(patternObj.pattern, 'i');
            if (regex.test(packageLower)) {
              threatLevel = 'pua';
              severity = patternObj.severity === 'critical' ? 'high' : 
                         patternObj.severity === 'high' ? 'high' : 'medium';
              riskScore = Math.max(riskScore, 50);
              reasons.push({ text: patternObj.reason, severity: patternObj.severity });
              break;
            }
          } catch (e) {
            // Invalid regex, skip
          }
        }
      } else if (threatLevel === 'safe') {
        // Fallback to simple patterns
        for (const pattern of defs.suspiciousPatterns || []) {
          try {
            const regex = new RegExp(pattern, 'i');
            if (regex.test(packageLower)) {
              threatLevel = 'pua';
              severity = 'medium';
              riskScore = Math.max(riskScore, 50);
              reasons.push({ text: `Nome package sospetto: ${pattern}`, severity: 'medium' });
              break;
            }
          } catch (e) {
            // Invalid regex
          }
        }
      }

      // === CHECK SUSPICIOUS APP NAMES ===
      if (threatLevel === 'safe' && defs.suspiciousAppNamesDetailed?.length > 0) {
        for (const nameObj of defs.suspiciousAppNamesDetailed) {
          if (appNameLower.includes(nameObj.name.toLowerCase())) {
            threatLevel = 'suspicious';
            severity = 'low';
            riskScore = Math.max(riskScore, 30);
            reasons.push({ text: nameObj.reason, severity: nameObj.severity });
            break;
          }
        }
      } else if (threatLevel === 'safe') {
        for (const name of defs.suspiciousAppNames || []) {
          if (appNameLower.includes(name.toLowerCase())) {
            threatLevel = 'suspicious';
            severity = 'low';
            riskScore = Math.max(riskScore, 30);
            reasons.push({ text: `Nome app sospetto: contiene "${name}"`, severity: 'low' });
            break;
          }
        }
      }

      // === CHECK DANGEROUS PERMISSION COMBINATIONS ===
      for (const combo of defs.dangerousPermissionCombos || []) {
        const comboPerms = combo.permissions || [];
        const hasAllPermissions = comboPerms.every(perm => 
          permissions.some(p => p.includes(perm.split('.').pop() || ''))
        );
        if (hasAllPermissions) {
          if (threatLevel === 'safe') {
            threatLevel = 'suspicious';
            severity = combo.severity === 'critical' ? 'high' : 
                       combo.severity === 'high' ? 'medium' : 'low';
          }
          riskScore = Math.max(riskScore, 
            combo.severity === 'critical' ? 70 : 
            combo.severity === 'high' ? 50 : 35
          );
          reasons.push({ 
            text: combo.reason || 'Combinazione permessi pericolosa rilevata', 
            severity: combo.severity || 'medium'
          });
        }
      }

      // === ADD RISK FOR MANY DANGEROUS PERMISSIONS ===
      if (dangerousPermissions.length >= 5 && threatLevel === 'safe') {
        riskScore = Math.max(riskScore, 25);
        reasons.push({ 
          text: `App richiede ${dangerousPermissions.length} permessi sensibili`, 
          severity: 'low' 
        });
      }
    }

    // Get recommendation from threat category
    const category = defs.threatCategories?.[threatLevel] || 
      defs.threatCategories?.safe || 
      { action: 'Nessuna azione richiesta' };

    return {
      packageName: app.packageName,
      appName: app.appName,
      iconBase64: app.iconBase64,
      threatLevel,
      severity,
      reasons,
      permissions,
      dangerousPermissions,
      isSystemApp: app.isSystemApp || false,
      recommendation: category.action,
      riskScore
    };
  }, []);

  // ==========================================
  // GET SYSTEM SECURITY STATUS
  // ==========================================

  const getSystemSecurityStatus = useCallback(async (): Promise<SystemSecurityStatus | null> => {
    try {
      if (!Capacitor.isNativePlatform()) return null;
      
      const securityData = await DeviceDiagnostics.getSecurityStatus();
      
      return {
        isRooted: securityData.isRooted || false,
        isBootloaderUnlocked: securityData.isBootloaderUnlocked || false,
        isDeveloperOptionsEnabled: securityData.isDeveloperOptionsEnabled || false,
        isUsbDebuggingEnabled: securityData.isUsbDebuggingEnabled || false
      };
    } catch (error) {
      console.error('[MalwareScanner] Error getting security status:', error);
      return null;
    }
  }, []);

  // ==========================================
  // CALCULATE OVERALL RISK
  // ==========================================

  const calculateOverallRisk = useCallback((
    results: ScanResult[], 
    systemSecurity: SystemSecurityStatus | null
  ): { score: number; level: ScanSummary['riskLevel'] } => {
    let score = 0;

    // Risk from threats found
    const malwareCount = results.filter(r => r.threatLevel === 'malware' || r.threatLevel === 'trojan').length;
    const spywareCount = results.filter(r => r.threatLevel === 'spyware').length;
    const adwareCount = results.filter(r => r.threatLevel === 'adware').length;
    const riskwareCount = results.filter(r => r.threatLevel === 'riskware').length;
    const puaCount = results.filter(r => r.threatLevel === 'pua').length;
    const suspiciousCount = results.filter(r => r.threatLevel === 'suspicious').length;

    score += malwareCount * 30;
    score += spywareCount * 25;
    score += adwareCount * 15;
    score += riskwareCount * 10;
    score += puaCount * 5;
    score += suspiciousCount * 2;

    // Risk from system security
    if (systemSecurity) {
      if (systemSecurity.isRooted) score += 20;
      if (systemSecurity.isBootloaderUnlocked) score += 10;
      if (systemSecurity.isUsbDebuggingEnabled) score += 5;
    }

    // Cap at 100
    score = Math.min(100, score);

    // Determine level
    let level: ScanSummary['riskLevel'] = 'safe';
    if (score >= 80) level = 'critical';
    else if (score >= 50) level = 'high';
    else if (score >= 25) level = 'medium';
    else if (score > 0) level = 'low';

    return { score, level };
  }, []);

  // ==========================================
  // SAVE SCAN REPORT
  // ==========================================

  const saveScanReport = useCallback(async (
    summary: ScanSummary,
    results: ScanResult[],
    systemSecurity: SystemSecurityStatus | null,
    deviceInfo: Record<string, any>
  ) => {
    try {
      const threatDetails = results
        .filter(r => r.threatLevel !== 'safe')
        .map(r => ({
          packageName: r.packageName,
          appName: r.appName,
          threatLevel: r.threatLevel,
          severity: r.severity,
          reasons: r.reasons,
          riskScore: r.riskScore
        }));

      await supabase.functions.invoke('malware-definitions', {
        body: {
          action: 'saveScanReport',
          report: {
            deviceToken: deviceInfo.deviceId,
            scanType: 'full',
            definitionsVersion: summary.definitionsVersion,
            appsScanned: summary.scannedApps,
            threatsFound: summary.malwareCount + summary.spywareCount + summary.adwareCount + 
                          summary.riskwareCount + summary.puaCount + summary.suspiciousCount,
            malwareCount: summary.malwareCount,
            spywareCount: summary.spywareCount,
            adwareCount: summary.adwareCount,
            riskwareCount: summary.riskwareCount,
            puaCount: summary.puaCount,
            suspiciousCount: summary.suspiciousCount,
            threatDetails,
            deviceInfo,
            securityStatus: systemSecurity,
            scanDurationMs: summary.scanDuration,
            overallRiskScore: summary.overallRiskScore,
            riskLevel: summary.riskLevel
          }
        }
      });

      console.log('[MalwareScanner] Scan report saved');
    } catch (error) {
      console.error('[MalwareScanner] Error saving scan report:', error);
    }
  }, []);

  // ==========================================
  // START SCAN
  // ==========================================

  const startScan = useCallback(async (quickScan: boolean = false) => {
    if (!Capacitor.isNativePlatform()) {
      setState(prev => ({ ...prev, error: 'Scanner disponibile solo su dispositivi Android' }));
      return;
    }

    setState({
      isScanning: true,
      progress: 0,
      currentApp: '',
      phase: 'loading_definitions',
      results: [],
      summary: null,
      systemSecurity: null,
      error: null,
      recentApps: []
    });

    const startTime = Date.now();

    try {
      // === PHASE 1: LOAD DEFINITIONS ===
      setState(prev => ({ 
        ...prev, 
        progress: 5, 
        currentApp: 'Caricamento database minacce...',
        phase: 'loading_definitions'
      }));

      const defs = await fetchDefinitions();
      if (!defs) {
        throw new Error('Impossibile caricare le definizioni malware dal database');
      }

      // === PHASE 2: FETCH APPS ===
      setState(prev => ({ 
        ...prev, 
        progress: 15, 
        currentApp: 'Recupero lista applicazioni...',
        phase: 'fetching_apps'
      }));

      const { apps } = await DeviceDiagnostics.getDangerousPermissions();
      
      if (!apps || apps.length === 0) {
        throw new Error('Nessuna applicazione trovata sul dispositivo');
      }

      // === PHASE 3: GET SYSTEM SECURITY ===
      setState(prev => ({ 
        ...prev, 
        progress: 20, 
        currentApp: 'Verifica sicurezza sistema...'
      }));

      const systemSecurity = await getSystemSecurityStatus();

      // === PHASE 4: ANALYZE APPS ===
      setState(prev => ({ 
        ...prev, 
        phase: 'analyzing'
      }));

      // Filter for quick scan (only non-system apps)
      const appsToScan = quickScan 
        ? apps.filter(app => !app.isSystemApp)
        : apps;

      const results: ScanResult[] = [];
      const totalApps = appsToScan.length;

      for (let i = 0; i < appsToScan.length; i++) {
        const app = appsToScan[i];
        const progress = 20 + Math.floor((i / totalApps) * 70);
        
        const result = analyzeApp({
          packageName: app.packageName,
          appName: app.appName,
          permissions: app.permissions,
          isSystemApp: app.isSystemApp,
          iconBase64: app.iconBase64
        }, defs);

        results.push(result);

        // Update UI with current app
        setState(prev => ({
          ...prev,
          progress,
          currentApp: app.appName || app.packageName,
          currentAppIcon: app.iconBase64,
          recentApps: [
            { 
              name: app.appName || app.packageName, 
              icon: app.iconBase64,
              status: result.threatLevel === 'safe' ? 'safe' : 'threat'
            },
            ...prev.recentApps.slice(0, 4)
          ]
        }));

        // Small delay for UI animation
        if (i % 5 === 0) {
          await new Promise(resolve => setTimeout(resolve, 30));
        }
      }

      // === PHASE 5: FINALIZE ===
      setState(prev => ({ 
        ...prev, 
        progress: 95, 
        currentApp: 'Elaborazione risultati...',
        phase: 'finalizing'
      }));

      // Calculate risk
      const { score: overallRiskScore, level: riskLevel } = calculateOverallRisk(results, systemSecurity);

      // Calculate summary
      const summary: ScanSummary = {
        totalApps: apps.length,
        scannedApps: appsToScan.length,
        malwareCount: results.filter(r => r.threatLevel === 'malware' || r.threatLevel === 'trojan').length,
        spywareCount: results.filter(r => r.threatLevel === 'spyware').length,
        adwareCount: results.filter(r => r.threatLevel === 'adware').length,
        riskwareCount: results.filter(r => r.threatLevel === 'riskware').length,
        puaCount: results.filter(r => r.threatLevel === 'pua').length,
        suspiciousCount: results.filter(r => r.threatLevel === 'suspicious').length,
        safeCount: results.filter(r => r.threatLevel === 'safe').length,
        scanDuration: Date.now() - startTime,
        scanDate: new Date(),
        overallRiskScore,
        riskLevel,
        definitionsVersion: defs.version
      };

      // Sort by risk score (highest first)
      results.sort((a, b) => b.riskScore - a.riskScore);

      // Save scan report
      await saveScanReport(summary, results, systemSecurity, {
        deviceId: 'device_' + Date.now(),
        platform: Capacitor.getPlatform()
      });

      // === COMPLETE ===
      setState({
        isScanning: false,
        progress: 100,
        currentApp: '',
        phase: 'complete',
        results,
        summary,
        systemSecurity,
        error: null,
        recentApps: []
      });

    } catch (error) {
      console.error('[MalwareScanner] Scan error:', error);
      setState(prev => ({
        ...prev,
        isScanning: false,
        phase: 'idle',
        error: error instanceof Error ? error.message : 'Errore durante la scansione'
      }));
    }
  }, [fetchDefinitions, analyzeApp, getSystemSecurityStatus, calculateOverallRisk, saveScanReport]);

  // ==========================================
  // CLEAR RESULTS
  // ==========================================

  const clearResults = useCallback(() => {
    setState({
      isScanning: false,
      progress: 0,
      currentApp: '',
      phase: 'idle',
      results: [],
      summary: null,
      systemSecurity: null,
      error: null,
      recentApps: []
    });
  }, []);

  // ==========================================
  // GET SCAN HISTORY
  // ==========================================

  const getScanHistory = useCallback(async (limit: number = 10) => {
    try {
      const { data, error } = await supabase.functions.invoke('malware-definitions', {
        body: { action: 'getScanHistory', limit }
      });

      if (error) throw error;
      return data.history || [];
    } catch (error) {
      console.error('[MalwareScanner] Error fetching scan history:', error);
      return [];
    }
  }, []);

  return {
    ...state,
    definitions,
    lastDefinitionsUpdate,
    isUpdatingDefinitions,
    startScan,
    clearResults,
    refreshDefinitions: fetchDefinitions,
    forceUpdateDefinitions,
    getScanHistory
  };
};
