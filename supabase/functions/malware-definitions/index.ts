import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const body = await req.json().catch(() => ({ action: 'getAll' }));
    const { action } = body;
    
    let responseData;
    
    switch (action) {
      case 'getVersion': {
        // Get only version info
        const { data, error } = await supabase
          .from('malware_definitions')
          .select('version, release_date, total_threats, malware_count, adware_count, spyware_count')
          .eq('is_active', true)
          .order('release_date', { ascending: false })
          .limit(1)
          .single();

        if (error) {
          console.error('[malware-definitions] Error fetching version:', error);
          throw error;
        }

        responseData = {
          version: data.version,
          releaseDate: data.release_date,
          lastUpdate: data.release_date,
          totalThreats: data.total_threats,
          malwareCount: data.malware_count,
          adwareCount: data.adware_count,
          spywareCount: data.spyware_count
        };
        break;
      }
        
      case 'checkPackage': {
        const { packageName } = body;
        
        if (!packageName) {
          throw new Error('packageName is required');
        }

        const { data, error } = await supabase
          .from('malware_definitions')
          .select('known_malware, known_adware, known_spyware, known_riskware')
          .eq('is_active', true)
          .order('release_date', { ascending: false })
          .limit(1)
          .single();

        if (error) throw error;

        const packageLower = packageName.toLowerCase();
        const isMalware = (data.known_malware as string[]).some(m => m.toLowerCase() === packageLower);
        const isAdware = (data.known_adware as string[]).some(a => a.toLowerCase() === packageLower);
        const isSpyware = (data.known_spyware as string[]).some(s => s.toLowerCase() === packageLower);
        const isRiskware = (data.known_riskware as string[]).some(r => r.toLowerCase() === packageLower);

        let threat = 'unknown';
        let severity = 'none';
        if (isMalware) { threat = 'malware'; severity = 'critical'; }
        else if (isSpyware) { threat = 'spyware'; severity = 'critical'; }
        else if (isAdware) { threat = 'adware'; severity = 'high'; }
        else if (isRiskware) { threat = 'riskware'; severity = 'medium'; }

        responseData = {
          packageName,
          threat,
          severity,
          found: isMalware || isAdware || isSpyware || isRiskware
        };
        break;
      }

      case 'saveScanReport': {
        const { report } = body;
        
        if (!report) {
          throw new Error('report is required');
        }

        const { data, error } = await supabase
          .from('scan_reports')
          .insert({
            device_token: report.deviceToken,
            customer_id: report.customerId || null,
            centro_id: report.centroId || null,
            loyalty_card_id: report.loyaltyCardId || null,
            scan_type: report.scanType || 'full',
            definitions_version: report.definitionsVersion,
            apps_scanned: report.appsScanned,
            threats_found: report.threatsFound,
            malware_count: report.malwareCount || 0,
            adware_count: report.adwareCount || 0,
            spyware_count: report.spywareCount || 0,
            riskware_count: report.riskwareCount || 0,
            pua_count: report.puaCount || 0,
            suspicious_count: report.suspiciousCount || 0,
            threat_details: report.threatDetails || [],
            device_info: report.deviceInfo || {},
            security_status: report.securityStatus || {},
            scan_duration_ms: report.scanDurationMs,
            overall_risk_score: report.overallRiskScore || 0,
            risk_level: report.riskLevel || 'safe'
          })
          .select()
          .single();

        if (error) {
          console.error('[malware-definitions] Error saving scan report:', error);
          throw error;
        }

        responseData = { success: true, reportId: data.id };
        break;
      }

      case 'getScanHistory': {
        const { deviceToken, customerId, limit = 10 } = body;
        
        let query = supabase
          .from('scan_reports')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(limit);

        if (deviceToken) {
          query = query.eq('device_token', deviceToken);
        } else if (customerId) {
          query = query.eq('customer_id', customerId);
        }

        const { data, error } = await query;

        if (error) throw error;

        responseData = { history: data || [] };
        break;
      }
        
      case 'getAll':
      default: {
        // Fetch active definitions from database
        const { data, error } = await supabase
          .from('malware_definitions')
          .select('*')
          .eq('is_active', true)
          .order('release_date', { ascending: false })
          .limit(1)
          .single();

        if (error) {
          console.error('[malware-definitions] Error fetching definitions:', error);
          throw error;
        }

        // Transform to expected format
        responseData = {
          version: data.version,
          releaseDate: data.release_date,
          lastUpdate: data.release_date,
          
          // Threat lists
          knownMalware: data.known_malware || [],
          knownAdware: data.known_adware || [],
          knownSpyware: data.known_spyware || [],
          knownRiskware: data.known_riskware || [],
          
          // Patterns and rules
          suspiciousPatterns: (data.suspicious_patterns || []).map((p: any) => 
            typeof p === 'string' ? p : p.pattern
          ),
          suspiciousAppNames: (data.suspicious_app_names || []).map((n: any) => 
            typeof n === 'string' ? n : n.name
          ),
          suspiciousPatternsDetailed: data.suspicious_patterns || [],
          suspiciousAppNamesDetailed: data.suspicious_app_names || [],
          dangerousPermissionCombos: data.dangerous_permission_combos || [],
          
          // Categories and metadata
          threatCategories: data.threat_categories || {},
          trustedSources: data.trusted_sources || [],
          systemAppWhitelist: data.system_app_whitelist || [],
          
          // Stats
          totalThreats: data.total_threats || 0,
          malwareCount: data.malware_count || 0,
          adwareCount: data.adware_count || 0,
          spywareCount: data.spyware_count || 0,
          
          // Changelog
          changelog: data.changelog || null,
          source: data.source || 'manual'
        };
        break;
      }
    }

    console.log(`[malware-definitions] Action: ${action}, Success`);

    return new Response(
      JSON.stringify(responseData),
      { 
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json',
          'Cache-Control': 'public, max-age=1800' // Cache for 30 minutes
        } 
      }
    );
  } catch (error) {
    console.error('[malware-definitions] Error:', error);
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        details: error
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );
  }
});
